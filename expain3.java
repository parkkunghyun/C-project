public class expain3 {
    
}
/*
CPU - 프로세스의 명령어를 해석하고 실행하는 장치
 IO - 파일을 읽고 쓰거나 네트워크 어딘가와 데이터를 주고 받는 것, 입출력 장치와도
 버스트 - 어떤현상이 짧은 시간에 중점적으로 일어남
 cpu burst - 프로세스가 cpu에서 한번에 연속적으로 실행되는 시간
 IO 버스트 -> 프로세스가 io 작업을 요청하고 결과를 기다리는 시간

 프로세스 인생은 cpu버스트와 io버스트의 연속이다!
 cpu bound 프로세스 - cpu burst가 많은 프로세스!
    동영상 편집 프로그램(편집하고 cpu 미친듯이 많이 사용!), 머신러닝 프로그램(연산 작업 많아서!)

IO bound 프로세스 -> (일반적인)백엔드 api 서버 -> 네트워크 통신 http request를 많이 받아서!
    cpu에서 처리하는 것보다 훨씬 오래 걸림

듀얼 코어 cpu에서 동작할 cpu bound프로그램을 구현한다면 몇개의 스레드 사용이 좋을까?

10억개 사진 읽어서 사람 있는지 마킹하는 프로그램

스레드 수가 적은게 무조건 빨리 끝나나? -> ㅇㅇ

cpu bound프로그램에서 적절한 스레드 수는 -> cpu개수 + 1 까지만 괜찮음!

왜?? -> 컨텍스트 스위칭과 연관!

cpu2개 프로세스 안에 스레드 4개 -> 각각 2개씩 cpu가 맡는다 -> 
각 코어마다 스레드가 한번에 하나씩만 실행됨! cpu바운드여서 cpu많이 잡아 먹음!

각 스레드가 서로 교체 될때마다 context switching이 됨!
cs는 cpu를 잡아먹는 추가비용이다! -> 그래서 코어 개수만큼만 스레드를 놔두면 cs를 안해도 되서 훨씬 효율적이다!

IO 바운드는 스레드 몇개로 구현해야할까? -> 이건 가이드 라인이 없다
여러 상황에 맞춰서 적절한 스레드 수를 찾아야... 
그래서 ==> API서버가 thread per request방식이라면?
몇개의 스레드들을 미리 만들어 놓을지 여러 상황 고려해서 결정하는 것이 필요!
    api의 하드웨어 스펙이 어느정도인지, 예상되는 트래픽 등

 */

 /*
 왜 동기화가 중요할까?

 하나의 객체를 두개의 스레드가 접근할때 생기는 일! 

귤 2박스에서 상한 귤 세기! -> 스레드 하나당 한 박스를 담당! 싱글 코어
badCounter를 공유한다!
현재 heap메모리에는 badCounter객체가 있다 state = 0;
싱글코어여서 멀티 쓰레딩이 됨 -> 컨텍스트 스위칭이 반복된다

for (귤 in 귤박스) {
    if (귤 상태 is 불량) {
        badCounter.increament();
    }
 }

 public clas Counter {
    private int state = 0;
    public void increment() { state++; }
    public int get() { return state; }
 }

increment()에는 하나의 코드만 들어기있다
이게 cpu레벨에서 state++이 어떻게 동작되는지 알아야함!

LOAD State to R1 -> R1이라는 레지스터로 로드
R1 = R1 + 1 -> 레지스터에서 1을 더함
STORE R1 to state -> 레지스터 값을 state에 저장하기!
 --> cpu가 이해할 수 있는 언어

저 계산이 다 끝나기 전에 컨텍스트 스위칭이 되면!!!!
제대로 결과가 반영되지 않을 수도 있다!

race condition(경쟁 조건) -> 여러프로세스나 스레드가 동시에 같은 데이터를 조작할때
타이밍이나 접근 순서에 따라 결과가 달라질 수 있는 상황!

synchronization(동기화)-> 여러 프로세스/스레드를 동시에 실행해도 공유 데이터의 일관성을 유지

이미 실행중인 스레드가 있으면 다른 스레드가 사용못하게 기다리게 하기!

critical section(임계영역역
공유 데이터의 일관성을 보장하기 위해 -> 하나의 프로세스 / 스레드만 진입해서 실행 가능한 영역

해결책 
-> mutual exclusion(상호 배제 한번에 하나의 프로세스나 스레드만 실행)/
-> progress(진행 현재 비어있으면 진행시키기!)
-> bounded waiting(한정된 대기!)

Thread-unsafe -> 만약 한번에 하나의 데이터만 접근하지 못한다면 동기화를 시켜줘야함!
*/

/**
어떻게 mutual exclusion을 보장할수 있을까>
lock을 사용!
do {
    acquire lock -> 하나의 
        critical section
    release lock
} while

여러 스레드들이 lock에 접근함 -> lock 획득에 성공한 스레드가 그때부터 criticalsection 들어감!
cpu에서 사용하기 때문에 같은 메모리 영역에 대해 동시에 실행되지 않음!
그래서 스레드들이 동시에 lock을 사용할 수 없다!

스핀락 -> 락을 가질 수 있을때까지 반복 확인 -> 기다리는 동한 cpu를 낭비하긴 함 


 */